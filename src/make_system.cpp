// Copyright 2012-2019 Richard Copley
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "mswin.h"

#include "make_system.h"
#include "compiler.h"
#include "memory.h"
#include "rotor.h"
#include "vector.h"
#include <cstring>
#include <utility>

// Return the number of positive-sense triangles in the spherical tiling
// generated by the Moebius triangle with dihedral angles pi/p, pi/q and pi/r.
constexpr unsigned moebius_order (unsigned p, unsigned q, unsigned r)
{
  return (2 * p * q * r) / (q * r + r * p + p * q - p * q * r);
}

NOINLINE unsigned sigma_inverse (unsigned dart, unsigned order)
{
  if (dart % order < 1u) {
    dart += order;
  }
  return dart - 1u;
}

// Construct a dart system for the spherical tiling and find node coordinates.
unsigned make_system (const unsigned (& p) [3],
                      const float (& triangle) [3] [4],
                      float (* nodes) [4], std::uint8_t (* indices) [6])
{
  const unsigned n = moebius_order (p [0], p [1], p [2]);
  void * memory = allocate (3 * 6 * n * sizeof (unsigned));
  unsigned * array = reinterpret_cast <unsigned *> (memory);
  unsigned * alpha = array;            // Opposite dart in the same edge.
  unsigned * sigma = array + 6 * n;    // Next dart around same origin node.
  unsigned * origin = array + 12 * n;  // Map from dart to its start node.
  unsigned next [3];                   // First dart of next free node of type.
  unsigned a [3];                      // Cursor darts.
  unsigned mu [3] = { 0, 1, 2 };       // Tracks the type of the current darts.
  bool even = true;                    // Tracks the parity of mu.

  // Initialize alpha to undefined.
  constexpr unsigned undef = -1;
  std::memset (alpha, '\xff', 6 * n * sizeof 0 [alpha]);

  // Choose some permutation sigma with the necessary disjoint-cycle structure.
  // Initialize origin, next and a, and copy vertices from triangle to nodes.
  unsigned dart = 0, node = 0;
  for (unsigned i = 0; i != 3; ++ i) {
    a [i] = dart + 1;
    next [i] = dart + 2 * p [i];
    store4f (nodes [node], load4f (triangle [i]));
    for (unsigned m = 0; m != n / p [i]; ++ m) {
      unsigned predecessor = dart + 2 * p [i] - 1;
      for (unsigned j = 0; j != 2 * p [i]; ++ j) {
        predecessor [sigma] = dart;
        origin [dart] = node;
        predecessor = dart ++;
      }
      ++ node;
    }
  }

  ALIGNED16 rotor_t rotate;
  rotate.about (nodes [0], -6.28318531f / ui2f (p [0]));

  // Extend alpha to a fixed point free involution, maintaining the invariant
  // d[alpha] == undef || d == d[alpha][sigma][alpha][sigma][alpha][sigma]
  // for all darts d, and find the coordinates of the remaining nodes.
  while (true) {
    a [0] [sigma] [alpha] = a [1];
    a [1] [sigma] [alpha] = a [2];
    a [2] [sigma] [alpha] = a [0];

    a [0] = a [0] [sigma];
    if (a [0] [sigma] [alpha] != undef) {
      a [0] = a [1] [sigma];
      if (a [0] [sigma] [alpha] != undef) {
        break;
      }
      std::swap (mu [0], mu [2]);
      std::swap (mu [0], mu [1]);
      rotate.about (nodes [origin [a [0]]], -6.28318531f / ui2f (p [mu [0]]));
    }

    std::swap (mu [1], mu [2]);
    even = ! even;

    a [2] = sigma_inverse (a [0] [alpha], 2 * p [mu [2]]);
    if (a [0] [sigma] [sigma] [alpha] != undef) {
      a [1] = a [0] [sigma] [sigma] [alpha] [sigma] [alpha] [sigma];
    }
    else {
      // Find the coordinates of a new node.
      a [1] = next [mu [1]] + even;
      next [mu [1]] += 2 * p [mu [1]];
      rotate (nodes [origin [a [0] [alpha] [sigma] [alpha]]],
              nodes [origin [a [1]]]);
    }

    if (a [2] [alpha] == undef) {
      unsigned b [3];
      b [1] = sigma_inverse (a [2], 2 * p [mu [2]]);
      if (b [1] [alpha] != undef) {
        b [0] = sigma_inverse (b [1] [alpha], 2 * p [mu [0]]);
        b [2] = a [1] [sigma];

        b [0] [sigma] [alpha] = b [1];
        b [1] [sigma] [alpha] = b [2];
        b [2] [sigma] [alpha] = b [0];
      }
    }
  }

  //    X1    Use the dart system to construct blocks {X0, Z1, Y0, X1, Z0, Y1}
  //   /  \   of nodes, one block for each positive-sense triangle X0 Y0 Z0.
  //  Y0--Z0  The nodes and index blocks are stored in a vertex array object.
  //  |\  /|  Each invocation of the geometry shader accepts a block of 6 nodes
  //  | X0 |  and emits the vertex figure for a polyhedron vertex at a point
  //  |/  \|  inside the spherical triangle X0 Y0 Z0. Drawing n copies of the
  //  Z1  Y1  vertex figure produces a complete polyhedron.

  for (unsigned i = 0; i != n / p [0]; ++ i) {
    unsigned d = 2 * p [0] * i;
    for (unsigned m = 0; m != p [0]; ++ m) {
      std::uint8_t (& block) [6] = indices [p [0] * i + m];
      block [0] = origin [d];
      block [1] = origin [d = d [alpha]];
      block [2] = origin [d = d [sigma] [alpha]];
      block [3] = origin [d = d [sigma] [sigma] [sigma] [alpha]];
      block [4] = origin [d = d [sigma] [alpha]];
      block [5] = origin [d = d [sigma] [sigma] [sigma] [alpha]];
      d = d [sigma] [alpha] [sigma];
    }
  }

  deallocate (memory);
  return n;
}
